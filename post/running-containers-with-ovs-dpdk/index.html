<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Running Containers With OVS-DPDK - 享受编程 - Coding Your Ambition.</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Meoop" /><meta name="description" content=" OVS-DPDK 是什么 OVS-DPDK 为容器提供网络支持  基于 DPDK 的应用 基于内核协议栈的应用   OVS-DPDK 容器网络方案验证  搭建 DPDK 环境 编译运行 OVS-DPDK DPDK 应用的容器 基于内核协议栈的应用（使用 veth pair 连接 ovs-dpdk） 基于内核协议栈的应用（使用 tap 连接 ovs-dpdk 的 virtio-user 接口）   厂商方案  美团点评容器平台网络架构 网易 Intel   参考文章   DPDK(Data Plane Development Kit)，即数据平面开发工具包，是一组用于快速数据包处理的数据平面库和网络接口控制器驱动程序，DPDK 为 x86，ARM 和 PowerPC 处理器提供编程框架，可以更快地开发高速数据包网络应用程序。该平台采用 BSD 许可证发布，目前作为 Linux Foundation 下的开源项目进行管理。
 在 X86 架构中，处理数据包的传统方式是 CPU 中断方式，即网卡驱动接收到数据包后通过中断通知 CPU 处理，然后由 CPU 拷贝数据并交给协议栈。在数据量大时，这种方式会产生大量 CPU 中断，导致 CPU 无法运行其他程序。而 DPDK 则采用轮询方式实现数据包处理过程：DPDK 重载了网卡驱动，在收到数据包后不中断通知 CPU，而是将数据包通过零拷贝技术存入内存，这时应用层程序就可以通过 DPDK 提供的接口，直接从内存读取数据包。这种处理方式节省了 CPU 中断时间、内存拷贝时间，并向应用层提供了简单易行且高效的数据包处理方式，使得网络应用的开发更加方便。但同时，由于需要重载网卡驱动，因此该开发包目前只能用在部分网络处理芯片的网卡中。
" /><meta name="keywords" content="container, ovs, dpdk" />






<meta name="generator" content="Hugo 0.69.0 with theme even" />


<link rel="canonical" href="http://blog.meoop.me/post/running-containers-with-ovs-dpdk/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.bcd489339cac29b395f315f2a2e16bf29afa8cdf7b20ca5b348385d0971a5db7.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Running Containers With OVS-DPDK" />
<meta property="og:description" content="
OVS-DPDK 是什么
OVS-DPDK 为容器提供网络支持

基于 DPDK 的应用
基于内核协议栈的应用


OVS-DPDK 容器网络方案验证

搭建 DPDK 环境
编译运行 OVS-DPDK
DPDK 应用的容器
基于内核协议栈的应用（使用 veth pair 连接 ovs-dpdk）
基于内核协议栈的应用（使用 tap 连接 ovs-dpdk 的 virtio-user 接口）


厂商方案

美团点评容器平台网络架构
网易
Intel


参考文章


DPDK(Data Plane Development Kit)，即数据平面开发工具包，是一组用于快速数据包处理的数据平面库和网络接口控制器驱动程序，DPDK 为 x86，ARM 和 PowerPC 处理器提供编程框架，可以更快地开发高速数据包网络应用程序。该平台采用 BSD 许可证发布，目前作为 Linux Foundation 下的开源项目进行管理。

在 X86 架构中，处理数据包的传统方式是 CPU 中断方式，即网卡驱动接收到数据包后通过中断通知 CPU 处理，然后由 CPU 拷贝数据并交给协议栈。在数据量大时，这种方式会产生大量 CPU 中断，导致 CPU 无法运行其他程序。而 DPDK 则采用轮询方式实现数据包处理过程：DPDK 重载了网卡驱动，在收到数据包后不中断通知 CPU，而是将数据包通过零拷贝技术存入内存，这时应用层程序就可以通过 DPDK 提供的接口，直接从内存读取数据包。这种处理方式节省了 CPU 中断时间、内存拷贝时间，并向应用层提供了简单易行且高效的数据包处理方式，使得网络应用的开发更加方便。但同时，由于需要重载网卡驱动，因此该开发包目前只能用在部分网络处理芯片的网卡中。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://blog.meoop.me/post/running-containers-with-ovs-dpdk/" />
<meta property="article:published_time" content="2018-07-31T12:56:20+08:00" />
<meta property="article:modified_time" content="2018-09-24T12:56:20+08:00" />
<meta itemprop="name" content="Running Containers With OVS-DPDK">
<meta itemprop="description" content="
OVS-DPDK 是什么
OVS-DPDK 为容器提供网络支持

基于 DPDK 的应用
基于内核协议栈的应用


OVS-DPDK 容器网络方案验证

搭建 DPDK 环境
编译运行 OVS-DPDK
DPDK 应用的容器
基于内核协议栈的应用（使用 veth pair 连接 ovs-dpdk）
基于内核协议栈的应用（使用 tap 连接 ovs-dpdk 的 virtio-user 接口）


厂商方案

美团点评容器平台网络架构
网易
Intel


参考文章


DPDK(Data Plane Development Kit)，即数据平面开发工具包，是一组用于快速数据包处理的数据平面库和网络接口控制器驱动程序，DPDK 为 x86，ARM 和 PowerPC 处理器提供编程框架，可以更快地开发高速数据包网络应用程序。该平台采用 BSD 许可证发布，目前作为 Linux Foundation 下的开源项目进行管理。

在 X86 架构中，处理数据包的传统方式是 CPU 中断方式，即网卡驱动接收到数据包后通过中断通知 CPU 处理，然后由 CPU 拷贝数据并交给协议栈。在数据量大时，这种方式会产生大量 CPU 中断，导致 CPU 无法运行其他程序。而 DPDK 则采用轮询方式实现数据包处理过程：DPDK 重载了网卡驱动，在收到数据包后不中断通知 CPU，而是将数据包通过零拷贝技术存入内存，这时应用层程序就可以通过 DPDK 提供的接口，直接从内存读取数据包。这种处理方式节省了 CPU 中断时间、内存拷贝时间，并向应用层提供了简单易行且高效的数据包处理方式，使得网络应用的开发更加方便。但同时，由于需要重载网卡驱动，因此该开发包目前只能用在部分网络处理芯片的网卡中。">
<meta itemprop="datePublished" content="2018-07-31T12:56:20&#43;08:00" />
<meta itemprop="dateModified" content="2018-09-24T12:56:20&#43;08:00" />
<meta itemprop="wordCount" content="3894">



<meta itemprop="keywords" content="container,ovs,dpdk," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Running Containers With OVS-DPDK"/>
<meta name="twitter:description" content="
OVS-DPDK 是什么
OVS-DPDK 为容器提供网络支持

基于 DPDK 的应用
基于内核协议栈的应用


OVS-DPDK 容器网络方案验证

搭建 DPDK 环境
编译运行 OVS-DPDK
DPDK 应用的容器
基于内核协议栈的应用（使用 veth pair 连接 ovs-dpdk）
基于内核协议栈的应用（使用 tap 连接 ovs-dpdk 的 virtio-user 接口）


厂商方案

美团点评容器平台网络架构
网易
Intel


参考文章


DPDK(Data Plane Development Kit)，即数据平面开发工具包，是一组用于快速数据包处理的数据平面库和网络接口控制器驱动程序，DPDK 为 x86，ARM 和 PowerPC 处理器提供编程框架，可以更快地开发高速数据包网络应用程序。该平台采用 BSD 许可证发布，目前作为 Linux Foundation 下的开源项目进行管理。

在 X86 架构中，处理数据包的传统方式是 CPU 中断方式，即网卡驱动接收到数据包后通过中断通知 CPU 处理，然后由 CPU 拷贝数据并交给协议栈。在数据量大时，这种方式会产生大量 CPU 中断，导致 CPU 无法运行其他程序。而 DPDK 则采用轮询方式实现数据包处理过程：DPDK 重载了网卡驱动，在收到数据包后不中断通知 CPU，而是将数据包通过零拷贝技术存入内存，这时应用层程序就可以通过 DPDK 提供的接口，直接从内存读取数据包。这种处理方式节省了 CPU 中断时间、内存拷贝时间，并向应用层提供了简单易行且高效的数据包处理方式，使得网络应用的开发更加方便。但同时，由于需要重载网卡驱动，因此该开发包目前只能用在部分网络处理芯片的网卡中。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Ambition</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Ambition</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Running Containers With OVS-DPDK</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-07-31 </span>
        <div class="post-category">
            <a href="/categories/container/"> container </a>
            <a href="/categories/network/"> network </a>
            </div>
        
      </div>
    </header>

    
    <div class="post-content">
      <ul>
<li><a href="#ovs-dpdk-%E6%98%AF%E4%BB%80%E4%B9%88">OVS-DPDK 是什么</a></li>
<li><a href="#ovs-dpdk-%E4%B8%BA%E5%AE%B9%E5%99%A8%E6%8F%90%E4%BE%9B%E7%BD%91%E7%BB%9C%E6%94%AF%E6%8C%81">OVS-DPDK 为容器提供网络支持</a>
<ul>
<li><a href="#%E5%9F%BA%E4%BA%8E-dpdk-%E7%9A%84%E5%BA%94%E7%94%A8">基于 DPDK 的应用</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8">基于内核协议栈的应用</a></li>
</ul>
</li>
<li><a href="#ovs-dpdk-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%96%B9%E6%A1%88%E9%AA%8C%E8%AF%81">OVS-DPDK 容器网络方案验证</a>
<ul>
<li><a href="#%E6%90%AD%E5%BB%BA-dpdk-%E7%8E%AF%E5%A2%83">搭建 DPDK 环境</a></li>
<li><a href="#%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C-ovs-dpdk">编译运行 OVS-DPDK</a></li>
<li><a href="#dpdk-%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%B9%E5%99%A8">DPDK 应用的容器</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E4%BD%BF%E7%94%A8-veth-pair-%E8%BF%9E%E6%8E%A5-ovs-dpdk">基于内核协议栈的应用（使用 veth pair 连接 ovs-dpdk）</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E4%BD%BF%E7%94%A8-tap-%E8%BF%9E%E6%8E%A5-ovs-dpdk-%E7%9A%84-virtio-user-%E6%8E%A5%E5%8F%A3">基于内核协议栈的应用（使用 tap 连接 ovs-dpdk 的 virtio-user 接口）</a></li>
</ul>
</li>
<li><a href="#%E5%8E%82%E5%95%86%E6%96%B9%E6%A1%88">厂商方案</a>
<ul>
<li><a href="#%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%84%E5%AE%B9%E5%99%A8%E5%B9%B3%E5%8F%B0%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84">美团点评容器平台网络架构</a></li>
<li><a href="#%E7%BD%91%E6%98%93">网易</a></li>
<li><a href="#intel">Intel</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">参考文章</a></li>
</ul>
<blockquote>
<p>DPDK(Data Plane Development Kit)，即数据平面开发工具包，是一组用于快速数据包处理的数据平面库和网络接口控制器驱动程序，DPDK 为 x86，ARM 和 PowerPC 处理器提供编程框架，可以更快地开发高速数据包网络应用程序。该平台采用 BSD 许可证发布，目前作为 Linux Foundation 下的开源项目进行管理。</p>
</blockquote>
<p>在 X86 架构中，处理数据包的传统方式是 CPU 中断方式，即网卡驱动接收到数据包后通过中断通知 CPU 处理，然后由 CPU 拷贝数据并交给协议栈。在数据量大时，这种方式会产生大量 CPU 中断，导致 CPU 无法运行其他程序。而 DPDK 则采用轮询方式实现数据包处理过程：DPDK 重载了网卡驱动，在收到数据包后不中断通知 CPU，而是将数据包通过零拷贝技术存入内存，这时应用层程序就可以通过 DPDK 提供的接口，直接从内存读取数据包。这种处理方式节省了 CPU 中断时间、内存拷贝时间，并向应用层提供了简单易行且高效的数据包处理方式，使得网络应用的开发更加方便。但同时，由于需要重载网卡驱动，因此该开发包目前只能用在部分网络处理芯片的网卡中。</p>
<h2 id="ovs-dpdk-是什么">OVS-DPDK 是什么</h2>
<p>OVS-DPDK 的数据平面通过 DPDK 快速通道进行处理，DPDK 的 PMD 模型使得数据收发绕过内核协议栈，达到数据包的快速收发。OVS-DPDK 有三层缓存表：Exact Match Cache（EMC）完全匹配缓存，无法通过通配符匹配；tuple space search (TSS) 元组空间搜索，使用 hash 表实现，可以通过通配符匹配； ofproto classifier table，被兼容 openflow 的控制器进行管理。</p>
<p>OVS-DPDK 与物理网卡的连接方式：利用 DPDK 提供的工具，使物理 NIC 直接绑定到 UIO 驱动上面，将物理网卡作为一个 port 绑定到 OVS-DPDK 上。这种情况下物理网卡将对系统不可见，也无法使用系统工具对网卡进行配置。</p>
<figure class="center">
    <img src="/images/post/Running-Containers-with-OVS-DPDK/179b7370.png"
         alt="OVS with DPDK"/> 
</figure>

<h2 id="ovs-dpdk-为容器提供网络支持">OVS-DPDK 为容器提供网络支持</h2>
<h3 id="基于-dpdk-的应用">基于 DPDK 的应用</h3>
<p>DPDK 官网容推荐器内运行 DPDK 应用有的两种模型，分片和汇聚，如下图所示。</p>
<figure class="center">
    <img src="/images/post/Running-Containers-with-OVS-DPDK/c12763f7.svg"
         alt="use_models_for_running_dpdk_in_containers"/> 
</figure>

<p>图 2 方案可以使用 vswitch 将上层的容器和底层的物理 NIC 解耦，可以通过 OVS-DPDK 实现高性能的容器应用。OVS-DPDK 可以创建 dpdkvhostuser 模式的 DPDK port，将这个 port mount 进容器的 network namespace 可以作为容器的虚拟网络接口，容器里面的 DPDK PMD 程序可以使用经过改进的 virtio-user 连接这个 port，通过 hugepage 内存区域（shared 模式）建立起到 OVS-DPDK 和物理 NIC 的高速数据通道。经过 OVS 流表配置，可以做到东西向和南北向的数据通道加速，整个过程 by-pass 宿主机的内核。</p>
<p>Intel 实现了 <a href="https://github.com/intel/vhost-user-net-plugin">vhost-user-net-plugin</a> cni 插件，实现在 OVS-DPDK 上建立 dpdkvhostuser 模式的 DPDK port，这个 port mount 进容器作为容器的虚拟网络接口，供 DPDK 应用使用。其结构如下所示：</p>
<figure class="center">
    <img src="/images/post/Running-Containers-with-OVS-DPDK/0d2723c6.png"
         alt="vhost user net plugin"/> 
</figure>

<p>DPDK 绕过了 Linux 内核协议栈，加速了数据的处理，用户可以在用户空间定制协议栈，满足自己的应用需求。用户业务可以借助 mTCP、f-stack 等用户态协议栈对业务应用进行改造，优化网络性能，实现高性能的网络应用。</p>
<h3 id="基于内核协议栈的应用">基于内核协议栈的应用</h3>
<p>基于内核协议栈的应用容器内部没有 virtio PMD 程序运行，所以只能连接传统的 OVS 端口，主要有两种可以参考的方案：</p>
<ul>
<li>使用 veth 对连接容器和 ovs，在<strong>这种模式下 ovs 将回落到 system datapath</strong>（如图1所示）；</li>
<li>使用 tap 将数据转发到 ovs-dpdk 的 virtio-user 接口，然后使用 dpdk 进行加速，在 tap 转发到 virtio-user 接口时会造成一次内存拷贝，会造成性能损失（如图2所示）。</li>
</ul>
<figure class="center">
    <img src="/images/post/Running-Containers-with-OVS-DPDK/f3edfb3f.png"/> 
</figure>

<p>两种模式都可以再通过设置 OVS 流表，将这些数据传输到基于 DPDK PMD 的 type=dpdk 的端口，这样可以在数据传输出网卡的后半程使用 DPDK 加速。这种情况下，数据在进入 OVS 端口并进行转发到 OVS DPDK PMD 绑定的 NIC 端口之后，就进入了 DPDK 高速通道。</p>
<h2 id="ovs-dpdk-容器网络方案验证">OVS-DPDK 容器网络方案验证</h2>
<h3 id="搭建-dpdk-环境">搭建 DPDK 环境</h3>
<p>1）、编译 dpdk</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># install build dependencies</span>
yum makecache
sudo yum install -y autoconf automake libtool wget vim gcc    <span class="se">\
</span><span class="se"></span>    gcc-c++  kernel-devel kernel-headers kernel net-tools     <span class="se">\
</span><span class="se"></span>    numactl-devel numactl-libs libpcap libpcap-devel pciutils <span class="se">\
</span><span class="se"></span>    python-six python-twisted-core python-zope-interface      <span class="se">\
</span><span class="se"></span>    openssl-devel openssl-libs

<span class="c1"># download dpdk 17.11.3</span>
wget http://fast.dpdk.org/rel/dpdk-17.11.3.tar.xz
tar -xvf dpdk-17.11.3.tar.xz

<span class="c1"># build dpdk</span>
<span class="nb">export</span> <span class="nv">DPDK_DIR</span><span class="o">=</span>/root/ovs-dpdk/dpdk-stable-17.11.3
<span class="nb">export</span> <span class="nv">DPDK_TARGET</span><span class="o">=</span>x86_64-native-linuxapp-gcc
<span class="nb">export</span> <span class="nv">DPDK_BUILD</span><span class="o">=</span><span class="nv">$DPDK_DIR</span>/<span class="nv">$DPDK_TARGET</span>
<span class="nb">export</span> <span class="nv">RTE_SDK</span><span class="o">=</span><span class="nv">$DPDK_DIR</span>
<span class="nb">export</span> <span class="nv">RTE_TARGET</span><span class="o">=</span>x86_64-native-linuxapp-gcc
make install <span class="nv">T</span><span class="o">=</span><span class="nv">$DPDK_TARGET</span> <span class="nv">DESTDIR</span><span class="o">=</span>install <span class="nv">RTE_SDK</span><span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>
</code></pre></td></tr></table>
</div>
</div><p>2）、配置 dpdk 环境</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 加载 igb_uio 模块</span>
modprobe uio_pci_generic
modprobe uio
modprobe vfio-pci
insmod build/kmod/igb_uio.ko

<span class="c1"># 在 grub.cfg 中添加参数分配1G大页</span>
<span class="nv">default_hugepagesz</span><span class="o">=</span>1GB <span class="nv">hugepagesz</span><span class="o">=</span>1G <span class="nv">hugepages</span><span class="o">=</span><span class="m">4</span>

<span class="c1"># 在 grub.cfg 中添加参数启用 iommu</span>
<span class="nv">iommu</span><span class="o">=</span>pt <span class="nv">intel_iommu</span><span class="o">=</span>on 
</code></pre></td></tr></table>
</div>
</div><p>查看系统的大页支持情况：
<figure class="center">
    <img src="/images/post/Running-Containers-with-OVS-DPDK/4c9ce83e.png"/> 
</figure>
</p>
<p>3）、绑定网卡，并测试 dpdk 环境是否 ok</p>
<p>查看当前的网卡驱动绑定状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"> ./usertools/dpdk-devbind.py --status
</code></pre></td></tr></table>
</div>
</div><figure class="center">
    <img src="/images/post/Running-Containers-with-OVS-DPDK/660d6448.png"/> 
</figure>

<p>绑定网卡到 igb_uio 驱动：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">ip link <span class="nb">set</span> ens4 down
ip link <span class="nb">set</span> ens9 down
./usertools/dpdk-devbind.py --bind<span class="o">=</span>igb_uio ens4
./usertools/dpdk-devbind.py --bind<span class="o">=</span>igb_uio ens9
</code></pre></td></tr></table>
</div>
</div><figure class="center">
    <img src="/images/post/Running-Containers-with-OVS-DPDK/5864fa5e.png"/> 
</figure>

<p>运行 testpmd 程序进行测试，可以看到数据包在两个接口间的转发情况，表示 dpdk 环境安装ok：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">./x86_64-native-linuxapp-gcc/app/testpmd -- -i
</code></pre></td></tr></table>
</div>
</div><figure class="center">
    <img src="/images/post/Running-Containers-with-OVS-DPDK/d8b7d8b0.png"/> 
</figure>

<h3 id="编译运行-ovs-dpdk">编译运行 OVS-DPDK</h3>
<p>1）、编译 OVS-DPDK (注意 ovs 和 dpdk 的版本是否匹配，参考官网 <a href="http://docs.openvswitch.org/en/latest/faq/releases/">FAQ</a>)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 下载 openvswitch 2.9.2 源码</span>
wget http://openvswitch.org/releases/openvswitch-2.9.2.tar.gz

<span class="c1"># build and install</span>
<span class="nv">LANGUAGE</span><span class="o">=</span>en_US.UTF-8 <span class="nv">LC_ALL</span><span class="o">=</span>en_US.UTF-8 <span class="nv">LANG</span><span class="o">=</span>en_US.UTF-8 ./boot.sh
./configure --with-dpdk<span class="o">=</span><span class="nv">$DPDK_BUILD</span>         <span class="se">\
</span><span class="se"></span>            --prefix<span class="o">=</span>/usr --sysconfdir<span class="o">=</span>/etc <span class="se">\
</span><span class="se"></span>            --localstatedir<span class="o">=</span>/var
make <span class="o">&amp;&amp;</span> make install
</code></pre></td></tr></table>
</div>
</div><p>2）、配置 ovs-dpdk</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 启动 ovs-dpdk</span>
/usr/share/openvswitch/scripts/ovs-ctl start

<span class="c1"># 配置 ovs-dpdk</span>
ovs-vsctl --no-wait <span class="nb">set</span> Open_vSwitch . other_config:dpdk-init<span class="o">=</span><span class="nb">true</span>
ovs-vsctl --no-wait <span class="nb">set</span> Open_vSwitch . other_config:dpdk-socket-mem<span class="o">=</span><span class="s2">&#34;1024,0&#34;</span>
ovs-vsctl --no-wait <span class="nb">set</span> Open_vSwitch . other_config:pmd-cpu-mask<span class="o">=</span>0x2

<span class="c1"># 创建一个支持 dpdk 的网桥</span>
ovs-vsctl add-br ovs-br0 -- <span class="nb">set</span> bridge ovs-br0 <span class="nv">datapath_type</span><span class="o">=</span>netdev

<span class="c1"># 创建 dpdk 接口并绑定到物理网卡</span>
ovs-vsctl add-port ovs-br0 dpdkprot01 -- <span class="nb">set</span> Interface dpdkprot01 <span class="nv">type</span><span class="o">=</span>dpdk options:dpdk-devargs<span class="o">=</span>0000:00:08.0

<span class="c1"># 创建 dpdk vhost-user 接口</span>
ovs-vsctl add-port ovs-br0 vhost-user0 -- <span class="nb">set</span> Interface vhost-user0 <span class="nv">type</span><span class="o">=</span>dpdkvhostuser
ovs-vsctl add-port ovs-br0 vhost-user1 -- <span class="nb">set</span> Interface vhost-user1 <span class="nv">type</span><span class="o">=</span>dpdkvhostuser

<span class="c1"># 创建流表</span>
ovs-ofctl add-flow ovs-br0 <span class="nv">in_port</span><span class="o">=</span>1,idle_timeout<span class="o">=</span>0,action<span class="o">=</span>output:2
ovs-ofctl add-flow ovs-br0 <span class="nv">in_port</span><span class="o">=</span>2,idle_timeout<span class="o">=</span>0,action<span class="o">=</span>output:1
</code></pre></td></tr></table>
</div>
</div><h3 id="dpdk-应用的容器">DPDK 应用的容器</h3>
<p>实验环境：</p>
<ul>
<li>支持 dpdk 的网桥 ovs-br0</li>
<li>4个 dpdk vhost-user 接口</li>
<li>pktgen 容器（用于生成数据包）和 testpmd 容器（流量转发）</li>
<li>配置流表 2&lt;&ndash;&gt;3 1&lt;&ndash;&gt;4</li>
</ul>
<p>连接情况如下：
<figure class="center">
    <img src="/images/post/Running-Containers-with-OVS-DPDK/d84b2256.png"/> 
</figure>
</p>
<p>1）、构建 pktgen 和 testpmd 镜像</p>
<p>pkktgen Dockerfile 如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="k">FROM</span><span class="s"> centos:latest</span><span class="err">
</span><span class="err"></span><span class="k">RUN</span> yum update -y <span class="o">&amp;&amp;</span> yum install -y iproute numactl-libs numactl libpcap pciutils<span class="err">
</span><span class="err"></span><span class="k">COPY</span> ./pktgen-3.5.0/ /root/pktgen-3.5.0<span class="err">
</span><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /root/pktgen-3.5.0</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>testpmd Dockerfile 如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="k">FROM</span><span class="s"> centos:latest</span><span class="err">
</span><span class="err"></span><span class="k">RUN</span> yum update -y <span class="o">&amp;&amp;</span> yum install -y iproute numactl-libs numactl libpcap pciutils<span class="err">
</span><span class="err"></span><span class="k">COPY</span> ./dpdk-stable-17.11.3/ /root/dpdk-stable-17.11.3/<span class="err">
</span><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /root/dpdk-stable-17.11.3</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>2）、运行并设置 ovs-dpdk</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 启动 ovs-dpdk</span>
/usr/share/openvswitch/scripts/ovs-ctl start

<span class="c1"># 配置 ovs-dpdk</span>
ovs-vsctl --no-wait <span class="nb">set</span> Open_vSwitch . other_config:dpdk-init<span class="o">=</span><span class="nb">true</span>
ovs-vsctl --no-wait <span class="nb">set</span> Open_vSwitch . other_config:dpdk-socket-mem<span class="o">=</span><span class="s2">&#34;1024,0&#34;</span>

<span class="c1"># 创建一个支持 dpdk 的网桥</span>
ovs-vsctl add-br ovs-br0 -- <span class="nb">set</span> bridge ovs-br0 <span class="nv">datapath_type</span><span class="o">=</span>netdev

<span class="c1"># 创建 dpdk 接口并绑定到物理网卡</span>
ovs-vsctl add-port ovs-br0 dpdkprot01 -- <span class="nb">set</span> Interface dpdkprot01 <span class="nv">type</span><span class="o">=</span>dpdk options:dpdk-devargs<span class="o">=</span>0000:00:08.0

<span class="c1"># 创建 dpdk vhost-user 接口</span>
ovs-vsctl add-port ovs-br0 vhost-user1 -- <span class="nb">set</span> Interface vhost-user1 <span class="nv">type</span><span class="o">=</span>dpdkvhostuser
ovs-vsctl add-port ovs-br0 vhost-user2 -- <span class="nb">set</span> Interface vhost-user2 <span class="nv">type</span><span class="o">=</span>dpdkvhostuser
ovs-vsctl add-port ovs-br0 vhost-user3 -- <span class="nb">set</span> Interface vhost-user3 <span class="nv">type</span><span class="o">=</span>dpdkvhostuser
ovs-vsctl add-port ovs-br0 vhost-user4 -- <span class="nb">set</span> Interface vhost-user4 <span class="nv">type</span><span class="o">=</span>dpdkvhostuser

<span class="c1"># 创建流表</span>
ovs-ofctl del-flows ovs-br0  <span class="c1"># 删除当前流表</span>
ovs-ofctl add-flow ovs-br0 <span class="nv">in_port</span><span class="o">=</span>1,idle_timeout<span class="o">=</span>0,action<span class="o">=</span>output:4
ovs-ofctl add-flow ovs-br0 <span class="nv">in_port</span><span class="o">=</span>4,idle_timeout<span class="o">=</span>0,action<span class="o">=</span>output:1
ovs-ofctl add-flow ovs-br0 <span class="nv">in_port</span><span class="o">=</span>2,idle_timeout<span class="o">=</span>0,action<span class="o">=</span>output:3
ovs-ofctl add-flow ovs-br0 <span class="nv">in_port</span><span class="o">=</span>3,idle_timeout<span class="o">=</span>0,action<span class="o">=</span>output:2
</code></pre></td></tr></table>
</div>
</div><p>系统状态如下：
<figure class="center">
    <img src="/images/post/Running-Containers-with-OVS-DPDK/454f3de7.png"/> 
</figure>
</p>
<figure class="center">
    <img src="/images/post/Running-Containers-with-OVS-DPDK/6d1a8e1c.png"/> 
</figure>

<p>3）、创建 pktgen 容器和 testpmd 容器，运行测试</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 运行 pktgen 容器</span>
docker run -i -t --rm --privileged   <span class="se">\
</span><span class="se"></span>    -v /dev/hugepages:/dev/hugepages <span class="se">\
</span><span class="se"></span>    -v /var/run/openvswitch:/var/run/openvswitch pktgen-docker

<span class="c1"># 在容器内运行 pktgen 程序，连接 vhost-user1 vhost-user2</span>
./app/x86_64-native-linuxapp-gcc/pktgen             <span class="se">\
</span><span class="se"></span>    --socket-mem <span class="m">1024</span> --file-prefix pktgen --no-pci <span class="se">\
</span><span class="se"></span>    --vdev <span class="s1">&#39;net_virtio_user1,mac=00:00:00:00:00:05,path=/var/run/openvswitch/vhost-user1&#39;</span> <span class="se">\
</span><span class="se"></span>    --vdev <span class="s1">&#39;net_virtio_user2,mac=00:00:00:00:00:01,path=/var/run/openvswitch/vhost-user2&#39;</span> <span class="se">\
</span><span class="se"></span>    -- -T -P -m <span class="s2">&#34;2.0,2.1&#34;</span>

<span class="c1"># 运行 dpdk 容器</span>
docker run -i -t --rm --privileged     <span class="se">\
</span><span class="se"></span>    -v /dev/hugepages:/dev/hugepages   <span class="se">\
</span><span class="se"></span>    -v /var/run/openvswitch:/var/run/openvswitch dpdk-docker

<span class="c1"># 在容器中运行 testpmd 程序，连接 vhost-user3 vhost-user4</span>
./x86_64-native-linuxapp-gcc/app/testpmd   <span class="se">\
</span><span class="se"></span>    --socket-mem <span class="m">1024</span> --file-prefix testpmd-docker --no-pci <span class="se">\
</span><span class="se"></span>    --vdev <span class="s1">&#39;virtio_user3,mac=00:00:00:00:00:02,path=/var/run/openvswitch/vhost-user3&#39;</span> <span class="se">\ </span>
    --vdev <span class="s1">&#39;virtio_user4,mac=00:00:00:00:00:03,path=/var/run/openvswitch/vhost-user4&#39;</span> <span class="se">\
</span><span class="se"></span>    -- -i --burst<span class="o">=</span><span class="m">64</span> --disable-hw-vlan --rxq<span class="o">=</span><span class="m">1</span> --txq<span class="o">=</span><span class="m">1</span> --rxd<span class="o">=</span><span class="m">256</span> --txd<span class="o">=</span><span class="m">256</span> -a
</code></pre></td></tr></table>
</div>
</div><p>在 pktgen 应用中设置发送到数据包数量，发送频率：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">set</span> all rate <span class="m">10</span>   
<span class="nb">set</span> <span class="m">0</span> count <span class="m">200</span>   <span class="c1"># 端口0发送200个包</span>
<span class="nb">set</span> <span class="m">1</span> count <span class="m">100</span>   <span class="c1"># 端口1发送100个包</span>
str               <span class="c1"># 启动发包</span>
</code></pre></td></tr></table>
</div>
</div><p>我们可以在 testpmd 中看到数据包的状态，使用命令 <code>show port stats all</code> 可以看到接口转发的包情况。结果如下图所示：</p>
<figure class="center">
    <img src="/images/post/Running-Containers-with-OVS-DPDK/49ede169.png"/> 
</figure>

<p>在 pktgen 中可以看到数据包发送接收情况，结果如下图：</p>
<figure class="center">
    <img src="/images/post/Running-Containers-with-OVS-DPDK/971033aa.png"/> 
</figure>

<p>也可以从 ovs 的接口中读到数据包的转发情况：</p>
<figure class="center">
    <img src="/images/post/Running-Containers-with-OVS-DPDK/2963783d.png"/> 
</figure>

<h3 id="基于内核协议栈的应用使用-veth-pair-连接-ovs-dpdk">基于内核协议栈的应用（使用 veth pair 连接 ovs-dpdk）</h3>
<p>实验环境：</p>
<ul>
<li>支持 dpdk 的网桥 ovs-br0</li>
<li>使用 ovs-docker 为容器添加网络</li>
<li>两个 centos 容器（互相 ping 测试）</li>
<li>配置流表</li>
</ul>
<figure class="center">
    <img src="/images/post/Running-Containers-with-OVS-DPDK/34804db8.png"/> 
</figure>

<p>1）、创建两个 centos 容器</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">docker run -i -t --rm --network<span class="o">=</span>none centos
</code></pre></td></tr></table>
</div>
</div><p>2）、使用 ovs-docker 配置容器网络</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">ovs-docker add-port ovs-br0 eth1 c13983ca7a73 --ipaddress<span class="o">=</span>192.168.99.100/24 --gateway<span class="o">=</span>192.168.99.1 --macaddress<span class="o">=</span><span class="s2">&#34;a2:c3:0d:49:7f:f8&#34;</span> --mtu<span class="o">=</span><span class="m">1450</span>
ovs-docker add-port ovs-br0 eth1 31ad2f628b48 --ipaddress<span class="o">=</span>192.168.99.101/24 --gateway<span class="o">=</span>192.168.99.1 --macaddress<span class="o">=</span><span class="s2">&#34;a2:c3:0d:49:7f:f9&#34;</span> --mtu<span class="o">=</span><span class="m">1450</span>
</code></pre></td></tr></table>
</div>
</div><p>从 ovs-br0 上可以看到多了两个接口:</p>
<figure class="center">
    <img src="/images/post/Running-Containers-with-OVS-DPDK/8894f52a.png"/> 
</figure>

<p>为这两个接口添加流表：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">ovs-ofctl add-flow ovs-br0 <span class="nv">in_port</span><span class="o">=</span>6,idle_timeout<span class="o">=</span>0,action<span class="o">=</span>output:5
ovs-ofctl add-flow ovs-br0 <span class="nv">in_port</span><span class="o">=</span>5,idle_timeout<span class="o">=</span>0,action<span class="o">=</span>output:6
</code></pre></td></tr></table>
</div>
</div><p>3）、测试容器网络</p>
<p>根据设置的 ip，让两个容器互相 ping ，观察结果如下，两个容器可以互相 ping 通：</p>
<figure class="center">
    <img src="/images/post/Running-Containers-with-OVS-DPDK/1ea7ac4b.png"/> 
</figure>

<p>4）、分析 ovs-docker 命令</p>
<p><code>ovs-docker</code> 命令是 ovs 官方提供的为容器添加网络支持的 python 脚本，其中添加端口的流程如下：</p>
<ul>
<li>创建 nate namespace</li>
<li>创建 veth 对</li>
<li>将 veth 对的一端添加到 ovs 上</li>
<li>将 veth 对的另一端加入到 net namespace 中，设置网卡名，ip，网关等信息</li>
</ul>
<h3 id="基于内核协议栈的应用使用-tap-连接-ovs-dpdk-的-virtio-user-接口">基于内核协议栈的应用（使用 tap 连接 ovs-dpdk 的 virtio-user 接口）</h3>
<p>实验环境：</p>
<ul>
<li>支持 dpdk 的网桥 ovs-br0</li>
<li>使用 ovs-docker 为容器网络</li>
<li>两个 centos 容器（互相 ping 测试）</li>
<li>配置流表</li>
</ul>
<figure class="center">
    <img src="/images/post/Running-Containers-with-OVS-DPDK/5b7c176a.png"/> 
</figure>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 加载 vhost 模块</span>
modprobe vhost
modprobe vhost_net

<span class="c1"># container----tap----vhost-net----ovs</span>
ovs-vsctl add-port ovs-br0 virtiouser0 -- <span class="nb">set</span> Interface virtiouser0 <span class="nv">type</span><span class="o">=</span>dpdk options:dpdk-devargs<span class="o">=</span>virtio_user0,path<span class="o">=</span>/dev/vhost-net,iface<span class="o">=</span>virtiouser0

<span class="c1"># container----tap----tap pmd----ovs</span>
ovs-vsctl add-port ovs-br0 tap01 -- <span class="nb">set</span> Interface tap01 <span class="nv">type</span><span class="o">=</span>dpdk options:dpdk-devargs<span class="o">=</span>net_tap01,path<span class="o">=</span>/dev/vhost-net,iface<span class="o">=</span>tap01
</code></pre></td></tr></table>
</div>
</div><h2 id="厂商方案">厂商方案</h2>
<h3 id="美团点评容器平台网络架构">美团点评容器平台网络架构</h3>
<figure class="center">
    <img src="/images/post/Running-Containers-with-OVS-DPDK/2f61708a.png"/> 
</figure>

<p>数据平面: 采用万兆网卡，结合 OVS-DPDK 方案，并进一步优化单流的转发性能，将几个 CPU 核绑定给 OVS-DPDK 转发使用，只需要少量的计算资源即可提供万兆的数据转发能力。OVS-DPDK 和容器所使用的 CPU 完全隔离，因此也不影响用户的计算资源。</p>
<p>控制平面: 我们使用 OVS 方案。该方案是在每个宿主机上部署一个自研的软件 Controller，动态接收网络服务下发的网络规则，并将规则进一步下发至OVS流表，决定是否对某网络流放行。</p>
<p>2017年总结优化：</p>
<ul>
<li>SRIOV 方式优化 local 性能。KNI 和 TAP 是常用的 DPDK 网络设备和内核数据交互的方案，为了提升 Local port 的性能，满足一些宿主机特殊场景。美团云将 SRIOV 和 BOND 结合，优化 OVS-DPDK bridge 的 local port 性能，现在 Local 可以跑满万兆。</li>
<li>OVS-DPDK 进程重启时间长，一直是存在的一个重要问题。美团云在今年上半年，重点解决了这个问题。这里采用的方案主要是双进程模式，以及 dpdk vhost 后端双进程模式，同时也对 restore flow 时间做了优化。60+VM，10G，2000 条流表的情况下，原生 OVS-DPDK 需要 2min+ 时间，经过改造后，可以达到 1s 以内。达到了 OVS-DPDK 进程平滑热升级，以及故障快速自恢复的功能。</li>
<li>跨 OVS-kernel 和 OVS-DPDK 热迁移。这里主要需要解决 OVS-DPDK 对 TSO、UFO 等 feature 支持, 因为原 OVS-kernel 的 VM 是默认打开这些 feature 的。而且需要解决 VM-&gt;VM， VM-NIC, VM-LOCAL， LOCAL-&gt;NIC 等多个路径的 offload 操作。</li>
</ul>
<h3 id="网易">网易</h3>
<p>网易的 ovs-dpdk 使用方案未知，网易的容器主要运行在虚拟机中，ovs-dpdk 的使用方案可能会是 ovs 端创建 dpdkvhostuser 接口，虚拟机启动会通过 virtio 驱动加载出 dpdk 的网卡，以此提供网络加速。
网易使用 OVS+VXLAN 方案。
网络层面：基于 DPDK/SR-IOV 实现高速网络包转发，网络包处理能力接近150W；
DDoS 攻击防护:基于 Intel DPDK 技术实现高性能实时抗攻击</p>
<h3 id="intel">Intel</h3>
<p>Intel Developer Zone 上一篇文章使用 ovs-dpdk 为 Docker 提供网络，其使用的方案为 veth 对直接连接容器和 ovs，文章地址为：
<a href="https://software.intel.com/en-us/articles/using-docker-containers-with-open-vswitch-and-dpdk-on-ubuntu-1710">Using Docker* Containers with Open vSwitch* and DPDK on Ubuntu* 17.10 | Intel® Software</a></p>
<p><a href="https://dpdksummit.com/Archive/pdf/2017Asia/DPDK-China2017-Tan-DPDK-in-Container.pdf">intel 在 2017 年 dpdk summit 上对 dpdk 提供容器网络加速，对于 tcp/ip 协议栈的应用提出了下面三种模型</a>：</p>
<p>1、 使用 tap 将数据转发到 ovs-dpdk 中处理数据。</p>
<figure class="center">
    <img src="/images/post/Running-Containers-with-OVS-DPDK/e87abfde.png"/> 
</figure>

<p>2、VF 作为容器网卡，然后在通过 dpdk 连接的 VF 接口转发到 ovs 处理，整个过程会 by-pass 内核，但其会受到物理网卡的限制。</p>
<figure class="center">
    <img src="/images/post/Running-Containers-with-OVS-DPDK/5e6a08dd.png"/> 
</figure>

<p>3、容器跑在虚拟机中
<figure class="center">
    <img src="/images/post/Running-Containers-with-OVS-DPDK/9981da62.png"/> 
</figure>
</p>
<h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="https://software.intel.com/en-us/articles/using-docker-containers-with-open-vswitch-and-dpdk-on-ubuntu-1710">Using Docker* Containers with Open vSwitch* and DPDK on Ubuntu* 17.10 | Intel® Software</a></li>
<li><a href="https://software.intel.com/en-us/articles/open-vswitch-with-dpdk-overview">Open vSwitch* with DPDK Overview | Intel® Software</a></li>
<li><a href="https://software.intel.com/en-us/articles/ovs-dpdk-datapath-classifier">OVS-DPDK Datapath Classifier | Intel® Software</a></li>
<li><a href="https://doc.dpdk.org/guides/howto/virtio_user_for_container_networking.html">Virtio_user for Container Networking — Data Plane Development Kit 18.08.0-rc2 documentation</a></li>
<li><a href="https://blog.csdn.net/cloudvtech/article/details/80495646">DPDK系列之十三：基于OVS-DPDK的容器数据通道分析 - CSDN博客</a></li>
<li><a href="https://blog.csdn.net/me_blue/article/details/78589592">ovs+dpdk-docker实践</a></li>
<li><a href="https://mp.weixin.qq.com/s/SHRQZ273CDkiw56ohrxjng">Intel DPDK 全面解读</a></li>
<li><a href="http://core.dpdk.org/supported/">DPDK硬件支持列表</a></li>
</ul>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Meoop</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2018-09-24
        <a href="https://github.com/Meoop/meoop.github.io.git/commit/c26d5fe8549621a70afdedf69c77622b3bab9b6d" title="new post: Running-Containers-with-OVS-DPDK.md">(c26d5fe)</a>
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/container/">container</a>
          <a href="/tags/ovs/">ovs</a>
          <a href="/tags/dpdk/">dpdk</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/resizing-persistent-volumes-using-kubernetes/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Resizing Persistent Volumes Using Kubernetes</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/%E4%BD%BF%E7%94%A8xmodmap%E5%8F%96%E6%B6%88linux%E4%B8%8B%E9%BC%A0%E6%A0%87%E4%B8%AD%E9%94%AE%E7%B2%98%E8%B4%B4%E5%8A%9F%E8%83%BD/">
            <span class="next-text nav-default">使用 xmodmap 取消 Linux 下鼠标中键粘贴功能</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'meoop';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="yilei108@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://www.stackoverflow.com/users/12249756/" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="http://localhost" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://www.facebook.com/lei.yi.908" class="iconfont icon-facebook" title="facebook"></a>
      <a href="https://www.linkedin.com/in/yilei/" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="https://github.com/Meoop" class="iconfont icon-github" title="github"></a>
      <a href="http://weibo.com/18722081826" class="iconfont icon-weibo" title="weibo"></a>
      <a href="http://www.zhihu.com/people/lei.yi" class="iconfont icon-zhihu" title="zhihu"></a>
  <a href="http://blog.meoop.me/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2015 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Meoop</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.d7b7ada643c9c1a983026e177f141f7363b4640d619caf01d8831a6718cd44ea.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-101122173-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
